module thalaswap_v1_interface::weighted_pool {
    use std::string::{String};

    use aptos_framework::coin::{Coin, MintCapability, BurnCapability};

    use aptos_std::event::{EventHandle};
    use aptos_std::table::{Table};

    use aptos_std::smart_table::{SmartTable};

    use fixed_point64::fixed_point64::{FixedPoint64};

    friend thalaswap::init;

    ///
    /// Error codes
    ///

    const ERR_UNAUTHORIZED: u64 = 0;

    // Initialization
    const ERR_INITIALIZED: u64 = 1;
    const ERR_UNINITIALIZED: u64 = 2;

    // Pool Conditions
    const ERR_WEIGHTED_POOL_EXISTS: u64 = 3;
    const ERR_WEIGHTED_POOL_NOT_EXISTS: u64 = 4;
    const ERR_WEIGHTED_POOL_INVALID_POOL_ASSETS: u64 = 5;
    const ERR_WEIGHTED_POOL_INVALID_POOL_WEIGHTS: u64 = 6;
    const ERR_WEIGHTED_POOL_INVALID_POOL_WEIGHT: u64 = 7;
    const ERR_WEIGHTED_POOL_INSUFFICIENT_LIQUIDITY: u64 = 8;
    const ERR_WEIGHTED_POOL_LOCKED: u64 = 9;
    const ERR_WEIGHTED_POOL_PRECISION_MULTIPLIER_NOT_EXISTS: u64 = 10;

    // Swap Conditions
    const ERR_WEIGHTED_POOL_INVALID_SWAP: u64 = 100;
    const ERR_WEIGHTED_POOL_INSUFFICIENT_INPUT: u64 = 101;

    // Management
    const ERR_WEIGHTED_POOL_INVALID_SWAP_FEE: u64 = 200;
    
    // Flashloan
    const ERR_WEIGHTED_POOL_FLASHLOAN_UNINITIALIZED: u64 = 300;
    const ERR_WEIGHTED_POOL_FLASHLOAN_INVALID_AMOUNT: u64 = 301;
    const ERR_WEIGHTED_POOL_FLASHLOAN_INSUFFICIENT_REPAY: u64 = 302;
    const ERR_WEIGHTED_POOL_FLASHLOAN_NOT_ONGOING: u64 = 303;
    const ERR_WEIGHTED_POOL_FLASHLOAN_INVALID_FEE: u64 = 304;

    ///
    /// Defaults
    ///

    const DEFAULT_SWAP_FEE_BPS: u64 = 30;
    const DEFAULT_FLASHLOAN_FEE_BPS: u64 = 1;

    ///
    /// Constants
    ///

    const POOL_TOKEN_DECIMALS: u8 = 8;
    const MINIMUM_LIQUIDITY: u64 = 100;

    const BPS_BASE: u64 = 10000;

    ///
    /// Resources
    ///

    // The boring code can be generated by the one-liner python script:
    // python3 -c "print('\n'.join(\"struct Weight_\" + str((i*5) + \" {}\" for i in range(1,20)))"
    struct Weight_5 {}
    struct Weight_10 {}
    struct Weight_15 {}
    struct Weight_20 {}
    struct Weight_25 {}
    struct Weight_30 {}
    struct Weight_35 {}
    struct Weight_40 {}
    struct Weight_45 {}
    struct Weight_50 {}
    struct Weight_55 {}
    struct Weight_60 {}
    struct Weight_65 {}
    struct Weight_70 {}
    struct Weight_75 {}
    struct Weight_80 {}
    struct Weight_85 {}
    struct Weight_90 {}
    struct Weight_95 {}

    /// Token issued to LPs represnting fractional ownership of the pool
    struct WeightedPoolToken<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> {}

    struct WeightedPool<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has key {
        asset_0: Coin<Asset0>,
        asset_1: Coin<Asset1>,
        asset_2: Coin<Asset2>,
        asset_3: Coin<Asset3>,

        weight_0: u64,
        weight_1: u64,
        weight_2: u64,
        weight_3: u64,

        // We also store `1 / (1 - swap_fee_ratio)` to save on gas on fee calculations in `swap_exact_out`
        swap_fee_ratio: FixedPoint64,
        inverse_negated_swap_fee_ratio: FixedPoint64,

        pool_token_mint_cap: MintCapability<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,
        pool_token_burn_cap: BurnCapability<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,

        reserved_lp_coin: Coin<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,

        events: WeightedPoolEvents<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>,
    }

    // Amending WeightedPool struct to include `precision_multipliers` vector
    // multipliers normalize each pooled asset's precision to base_pool::max_supported_decimals()
    // for example, MOD has 8 decimals, so the multiplier should be 1 (=10^0).
    // let's say USDC has 6, then the multiplier should be 100 (=10^(8-6))
    struct PrecisionMultipliers has key {
        // key: LP token type_name, value: vector of precision multipliers
        data: Table<String, vector<u64>>,
    }

    struct SwapFeeOverrides<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has key {
        traders: SmartTable<address, FixedPoint64>
    }

    struct WeightedPoolLookup has key {
        // key: LP token type_name, value: WeightedPoolInfo
        // this is used to help LP oracle to query the status of a pool using LP token name
        name_to_pool: Table<String, WeightedPoolInfo>,

        // key: unique pool ID, value: LP token type_name
        // this is to help DEX aggregator (e.g. Hippo) to iterate all pools
        id_to_name: Table<u64, String>,

        // Pool ID increments for each new pool
        next_id: u64,
    }

    /// Stores the status of a pool without "CoinType" generic type
    /// Can be used to query the status of a pool by LP token name
    struct WeightedPoolInfo has copy, store, drop {
        balances: vector<u64>,
        weights: vector<u64>,
        lp_coin_supply: u64
    }

    struct WeightedPoolParams has key {
        default_swap_fee_ratio: FixedPoint64,
        param_change_events: EventHandle<WeightedPoolParamChangeEvent>
    }
    
    /// Flashloan resource following "hot potato" pattern: https://medium.com/@borispovod/move-hot-potato-pattern-bbc48a48d93c
    /// This resource cannot be copied / dropped / stored, but can only be created and destroyed in the same module
    /// by `flashloan` and `pay_flashloan` functions
    struct Flashloan<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> {
        amount_0: u64,
        amount_1: u64,
        amount_2: u64,
        amount_3: u64,
    }
    
    /// We use a separate global storage for flashloan related structs because we want to do a backward compatible upgrade
    struct FlashloanHelper<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has key {
        /// true if there is a flashloan in progress, and other flashloan / swap / liquidity operations cannot be executed for the pool
        locked: bool, 
        /// flashloan fee in basis points
        flashloan_fee_bps: u64, 
        flashloan_events: EventHandle<FlashloanEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>
    }

    ///
    /// Events
    ///

    /// Event emitted when a pool is created
    struct WeightedPoolCreationEvent<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has drop, store {
        creator: address,
        amount_0: u64,
        amount_1: u64,
        amount_2: u64,
        amount_3: u64,
        minted_lp_coin_amount: u64,
        swap_fee_bps: u64,
    }

    /// Event emitted when a liquidity is added to a pool
    struct AddLiquidityEvent<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has drop, store {
        amount_0: u64,
        amount_1: u64,
        amount_2: u64,
        amount_3: u64,
        minted_lp_coin_amount: u64,
    }

    /// Event emitted when a liquidity is removed from a pool
    struct RemoveLiquidityEvent<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has drop, store {
        amount_0: u64,
        amount_1: u64,
        amount_2: u64,
        amount_3: u64,
        burned_lp_coin_amount: u64,
    }

    /// Event emitted when a swap is executed
    struct SwapEvent<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has drop, store {
        idx_in: u64,
        idx_out: u64,
        amount_in: u64,
        amount_out: u64,
        fee_amount: u64,
        pool_balance_0: u64,
        pool_balance_1: u64,
        pool_balance_2: u64,
        pool_balance_3: u64,
    }

    /// Event emitted when a protocol parameter is changed
    struct WeightedPoolParamChangeEvent has drop, store {
        name: String,

        prev_value: u64,
        new_value: u64
    }
    
    /// Event emitted when a flashloan is executed
    struct FlashloanEvent<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has drop, store {
        amount_0: u64,
        amount_1: u64,
        amount_2: u64,
        amount_3: u64,
    }

    struct WeightedPoolEvents<phantom Asset0, phantom Asset1, phantom Asset2, phantom Asset3, phantom Weight0, phantom Weight1, phantom Weight2, phantom Weight3> has store {
        pool_creation_events: EventHandle<WeightedPoolCreationEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,
        add_liquidity_events: EventHandle<AddLiquidityEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,
        remove_liquidity_events: EventHandle<RemoveLiquidityEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,
        swap_events: EventHandle<SwapEvent<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>,

        param_change_events: EventHandle<WeightedPoolParamChangeEvent>,
    }

    ///
    /// Functions
    ///

    public fun create_weighted_pool<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(
        _account: &signer,
        _asset_0: Coin<Asset0>,
        _asset_1: Coin<Asset1>,
        _asset_2: Coin<Asset2>,
        _asset_3: Coin<Asset3>
    ): Coin<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>> {
        abort 0
    }

    public fun add_liquidity<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(
        _coin_0: Coin<Asset0>,
        _coin_1: Coin<Asset1>,
        _coin_2: Coin<Asset2>,
        _coin_3: Coin<Asset3>
    ): (Coin<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>, Coin<Asset0>, Coin<Asset1>, Coin<Asset2>, Coin<Asset3>)
    {
        abort 0
    }

    public fun remove_liquidity<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(
        _lp_coin: Coin<WeightedPoolToken<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>>
    ): (Coin<Asset0>, Coin<Asset1>, Coin<Asset2>, Coin<Asset3>) {
        abort 0
    }

    /// First 9 type args define the pool to swap against. X is input coin type & Y is output coin type
    public fun swap_exact_in<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3, X, Y>(_coin_in: Coin<X>): Coin<Y> {
        abort 0
    }

    /// Enables a user to swap_exact_in, taking advantage of fee_overrides if present
    public fun swap_exact_in_fee_overrides<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3, X, Y>(
        _account: &signer,
        _coin_in: Coin<X>
    ): Coin<Y>  {
        abort 0
    }

    /// First 8 type args define the pool to swap against. X is input coin type & Y is output coin type
    public fun swap_exact_out<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3, X, Y>(_coin_in: Coin<X>, _amount_out: u64): (Coin<X>, Coin<Y>) {
        abort 0
    }

    /// Get flash loan coins.
    /// We allow borrowing any assets
    /// Returns loan coins along with Flashloan resource
    public fun flashloan<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(
        _amount_0: u64,
        _amount_1: u64,
        _amount_2: u64,
        _amount_3: u64
    ): (Coin<Asset0>, Coin<Asset1>, Coin<Asset2>, Coin<Asset3>, Flashloan<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>)
    {
        abort 0
    }

    /// Pay flash loan coins and destroy the Flashloan resource.
    /// User must pay back the loan coins plus the fee.
    public fun pay_flashloan<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(
        _coin_0: Coin<Asset0>,
        _coin_1: Coin<Asset1>,
        _coin_2: Coin<Asset2>,
        _coin_3: Coin<Asset3>,
        _loan: Flashloan<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>
    )
    {
        abort 0
    }

    // Public Getters

    public fun initialized(): bool {
        abort 0
    }

    #[view]
    public fun weighted_pool_exists<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(): bool {
        abort 0
    }
    
    #[view]
    // Returns **normalized** pool balances, weights, and lp coin supply
    public fun pool_info(_lp_coin_name: String): (vector<u64>, vector<u64>, u64) {
        abort 0
    }

    #[view]
    public fun pool_balances_and_weights<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(): (vector<u64>, vector<u64>)
    {
        abort 0
    }

    #[view]
    public fun swap_fee_ratio<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(): FixedPoint64 {
        abort 0
    }

    #[view]
    public fun swap_fee_ratio_with_overrides<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(_trader_address: address): FixedPoint64 {
        abort 0
    }

    #[view]
    public fun inverse_negated_swap_fee_ratio<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(): FixedPoint64 {
        abort 0
    }

    #[view]
    public fun next_pool_id(): u64 {
        abort 0
    }

    #[view]
    public fun lp_name_by_id(_id: u64): String {
        abort 0
    }
    
    #[view]
    public fun get_weight<WeightN>(): u64 {
        abort 0
    }

    #[view]
    public fun get_precision_multipliers<Asset0, Asset1, Asset2, Asset3>(): vector<u64> {
        abort 0
    }

    #[view]
    public fun flashloan_fee_bps<Asset0, Asset1, Asset2, Asset3, Weight0, Weight1, Weight2, Weight3>(): u64 {
        abort 0
    }
}
